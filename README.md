> TL;DR: я попытался сделать многопоточную реализацию, однако это оказалось куда сложнее чем я предполагал, особенно в условиях отсутствия в С++ из коробки каких-либо высокоуровневых примитивов. Поэтому я просто расписал возможные варианты параллельных алгоритмов и реализовал однопоточное решение.

---

1. [Алгоритм параллельного решения](#parallelsolution)
    - [Thread Pool](#parallelbicycle)
    - [Обрамление Thread Pool буферами](#parallelbuffers)
2. [Однопоточный алгоритм](#sequent)
    - [UNIX-way](#sequentunixway)
    - [Моя однопоточная реализация](#sequentmy)

# <a id="parallelsolution"></a>Алгоритм параллельного решения

### <a id="parallelbicycle"></a>Thread Pool. 
В очередь задач добавляются задачи вида *номер блока*; каждый поток считывает задачу, читает содержимое входного файла по необходимому смещению *размер блока * номер блока*, выполняет вызов функции хеширования и сохраняет результат по необходимому смещению *размер хеша * номер блока* в выходном файле.

Псевдокод к данному алгоритму работы:
```
...
// блокирующая очередь
// содержимое - номера блоков

queue = [0, 1, 2, 3, ... , n]

// количество доступных потоков за исключением основного потока
for thread_id = 0 to hardware_available_threads() - 1
    // функция запускаемая в каждом потоке
    thread.run()
            while True
                if queue.not_empty() 
                {
                    task_num = queue.pop_task()
                    offset = block_size * task_num
                    {
                        lock_guard<mutex> lock(inputfile)
                        // читаем с заданного смещения block_size или до EOF
                        block = read_file_block(offset)
                    }
                    hash = get_hash(block)
                    {
                        lock_guard<mutex> lock(outputfile)
                        // пишем по заданному смещению в файл
                        outfile.write(offset, hash)
                    }
                }
...
```

Использование отдельной очереди для хранения чисел, скорее всего, расточительство, однако мои попытки сделать это при помощи atomic переменной вели к race condition, а очередь является более устоявшимся способом распределения задач между ожидающими их появления потоками.

&#x2611; оно относительно простое в кодировании (очередь задач или её аналог во многих языках является примитивом из коробки);\
&#x2611; отсутствие потребности в промежуточных буферах;\
&#x2612; непоследовательный доступ к файлам. Считывающей головке жёсткого диска придётся несладко - возможно возникновение I/O bottleneck. C SSD будет лучше (как и всё в данной задаче);\
&#x2612; возможно это велосипед, который не едет.

### <a id="parallelbuffers"></a>Обрамление Thread Pool буферами

Работающий пул потоков можно обрамить одним или двумя промежуточными буферами, реализовав design pattern Product-Consumer.

- Буфер можно добавить перед пулом, чтобы отдельный поток считывал в него из исходного файла блоки данных, а остальные потоки брали из него и выполняли оставшуюся часть работы;
- Буфер можно добавить после пула, чтобы потоки считывали самостоятельно данные из файла, хешировали их и клали в результирующий буфер, а отдельный поток занимался последовательной записью в файл;
- Два буфера: в первый записываются прочитанные блоки данных, из которого блоки берут себе задания, а во второй кладут их, из которого отдельный поток записывает в выходной файл.

&#x2611; последовательное чтение и/или запись в файл;\
&#x2611; скорее всего это архитектурно более верное решение;\
&#x2612; это сложнее кодировать;\
&#x2612; необходимо следить за вместимостью буферов, чтобы не возникало page thrashing и ОС не пришлось скидывать/загружать страницы памяти с/на диск;\
&#x2612; необходимо следить за bottleneck, которые образуются. Может возникнуть ситуация, когда выбрана вычислительно сложная хеш функция и буфер перед пулом постоянно заполнен. Или буфера большую часть времени пустуют и пул простаивает.

# <a id="sequent"></a>Однопоточный алгоритм

В качестве хеш-функции я изначально выбрал MD5 (прилинковав openssl), однако потом на просторах гитхаба нашёл **многопоточное решение** этой задачи, в которой использовался CRC32. Мне хотелось посмотреть насколько моя однопоточная версия будет хуже многопоточной, поэтому я скомпилировал обе ради бенчмарков. По итогу, очень ожидаемо, на моём стареньком ноутбуке с HDD и всего 2 ядрами процессора моя топорная однопоточная реализация превзошла многопоточную с её наценками на синхронизацию потоков и прочее. Конечно же в системе с большими мощностями, по всей видимости, многопоточная во много раз превзойдёт однопоточную.

### <a id="sequentunixway"></a>UNIX-way

Наиболее быстрым для кодирования и понимания, тем более если вдруг эта задача разовая и не требует каких-то сверхоптимизаций было бы написать скрипт на баше (я написал его во многом для проверки правильности работы программы на С++)

```console
#!/bin/sh

echo -n '' > ans
split input.txt -b 1K tmp_
for i in tmp_*; do cat $i | gzip -c | tail -c8 | hexdump -n4 -e '"%u"' >> ans; done;
rm tmp_*
```

### <a id="sequentmy"></a>Моя однопоточная реализация

[![asciicast](https://asciinema.org/a/jdsqOJCR9zXmyEHT9JezIu4Hn.svg)](https://asciinema.org/a/jdsqOJCR9zXmyEHT9JezIu4Hn)

Демонстрация работы программы: 
- На вход программе подаю файл с одним байтом ('1') и прошу записать результат в output.txt. 
- Запускаю script.sh, который генерирует CRC32-хеш и записывает его в файл ans. 
- В результате работы файлы ans и output.txt одинаковы.

Если честно, то я все силы потратил на попытки реализовать многопоточную версию, поэтому однопоточную реализацию "до блеска" не доводил. 
